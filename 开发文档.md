# 开发文档

## 多客户端并发请求

```
go handleClient(conn) // 并发处理：Goroutines（Go 中的并发执行单位），用户无需手动分配线程。使用 go 关键字启动 Goroutine
//goroutine 泄漏（Goroutine Leak）

//如果 handleClient 里出现死循环，goroutine 永远不会结束，可能导致服务器占用过多资源。
//解决方案：使用 timeouts 或 context.WithCancel 来控制 goroutine 生命周期。
//数据竞争（Race Condition）

//如果多个客户端同时访问或修改共享数据（如 map），可能会引发数据竞争问题。
//解决方案：使用 sync.Mutex 互斥锁 或 sync.RWMutex 读写锁 保护共享数据。
//连接泄漏

//如果 handleClient 内部没有 defer conn.Close()，连接可能会一直占用资源，最终导致服务器崩溃。
//解决方案：确保 defer conn.Close()。
```

## 命令读取

```
[用的它]1.map[string]func() 方式：易维护 
2.switch:只实现几个命令时
3.方法分发机制：go-redis工业界代码使用的，每个 Redis 命令都有独立的方法（如 Set()、Get()）。通过 NewStatusCmd() 或 NewStringCmd() 构造一个 Redis 命令对象。最终调用 c.Process(ctx, cmd) 发送命令。
```

命令都有：


| PING | 返回PONG         | col3 |
| ---- | ---------------- | ---- |
| ECHO | 返回输入的字符串 |      |
| SET  | set key value    |      |

## 数据结构

## 测试

#### Version1:

用的go-redis的redis-cli:

> wget http://download.redis.io/redis-stable.tar.gz
>
> tar xzvf redis-stable.tar.gz
>
> cd redis-stable
>
> make

或者用nmap的ncat:先用的这个

> ncat localhost 6379

测试用例：

```shell
PS D:\workshop\Go\src\my-redis-go> ncat localhost 6379
*1        #参数个数
$4        #第一个参数长度
PING
+PONG      #回复
*2
$4
ECHO
$5
hello
$5
hello    #回复
*3   
$3
SET
$3
key
$5
value
+OK      #回复
*2
$3
GET
$3
key
$5
value    #回复
```

#### Version2:

引入redis-cli后，发现段错误：

```
PS D:\workshop\Go\src\my-redis-go\app> go run .\main.go
Server listening on :6379
DEBUG: EOF reached, possibly client disconnected.
Error parsing command: EOF

eaglesfikr@LAPTOP-K5A5D0SQ:/mnt/d/workshop/Go/src/my-redis-go/test/redis-7.2.4$ ./src/redis-cli -h 172.21.192.1 -p 6379 PING
Segmentation fault (core dumped)
```

难道时因为我在

看了下redis-cli的请求为（不含任何命令）

```
PS D:\workshop\Go\src\my-redis-go\test> go run .\printRESP.go
Listening for connections on 0.0.0.0:6379...
Array count: 2
Received line: *2
Bulk string length: 7
Received line: $7
Received line: COMMAND
Bulk string length: 4
Received line: $4
Received line: DOCS
```

重新写了一下，解决了



Version3:

添加CONFIG GET命令

添加KEYS （pattern）命令，而不只是KEYS *



